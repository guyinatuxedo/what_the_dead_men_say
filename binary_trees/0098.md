## Description

Given a binary tree, determine if it is a valid binary search tree (BST).

## Java Recursive

So how this solution works is this (my original one didn't work, so I got some help from leetcode). It keeps track of the maximum and minimum bounds for the current node. These bounds are influenced by if it's a left child, or a right child. For a child on the right, it has to be greater than that node, so the minimum bound is that value + 1. If a node is on the left, it has to be less than that, so the maximum bound has to be that value - 1. However if a node is on the right, the minimum bound get's updated but the maximum does not. The opposite is true if a node is on the left. So by doing this, we keep track of the bounds for that individual portion of the tree.

The runtime cost for this algorithm is `O(n)` where `n` is the number of nodes in the binary tree. The memory cost for this algorithm is `O(d)` where `d` is the depth of the binary tree, which is the maximum number of recursive calls on the call stack.

```
 */
class Solution 
{
    public boolean checkChild(TreeNode working, Integer max, Integer min)
    {
        boolean right, left;
        
        if (working == null) return true;
        
        if ((max != null) && (working.val >= max)) return false;
        if ((min != null) && (working.val <= min)) return false;
     
        right = checkChild(working.right, max, working.val);
        left = checkChild(working.left, working.val, min);
        
        return right && left;
    }
    
    public boolean isValidBST(TreeNode root) 
    {
        if (root == null) return true;
        return checkChild(root, null, null);
    }
}
```